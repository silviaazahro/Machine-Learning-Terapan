# -*- coding: utf-8 -*-
"""Predictive_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DEGIOuALWNdD9SSgaGY9rJrPfZ5Efe2S

## **1. Import Library**

Mengimport library-library yang dibutuhkan untuk membuat model
"""

import numpy as np  # operasi angka dan aljabar linear
import matplotlib.pyplot as plt  # untuk membuat grafik
import pandas as pd  # manipulasi dan analisis data
import seaborn as sns  # alat bantu visualisasi data

# Preprocessing dan evaluasi
from sklearn.preprocessing import OneHotEncoder, StandardScaler  # transformasi data kategorik dan normalisasi numerik
from sklearn.model_selection import train_test_split  # pemisahan data latih dan uji

# Model machine learning
from sklearn.ensemble import RandomForestClassifier  # model klasifikasi Random Forest
from xgboost import XGBClassifier  # model klasifikasi XGBoost
from lightgbm import LGBMClassifier  # model klasifikasi LightGBM

# Alat evaluasi performa model
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix  # metrik untuk mengevaluasi hasil prediksi

"""## **2. Data Loading**

Load dataset dari github
"""

dataset = "https://raw.githubusercontent.com/silviaazahro/Machine-Learning-Terapan/refs/heads/main/Predictive%20Analysis/healthcare-dataset-stroke-data.csv"
df = pd.read_csv(dataset)

"""Melihat sample dari data"""

df.head()

"""## **3. Exploratory Data Analysis (EDA)**

### 3.1. Deskripsi Variabel
"""

df.info()

df.describe()

"""### 3.2. Menangani Missing Value dan Outlier

Mengecek dataset apakah terdapat missing values
"""

df.isnull().sum()

"""Karena masih ada missing value kolom **'bmi'** jadi kita imputasi dengan Mean dan Median"""

# Imputasi dengan mean
df['bmi'].fillna(df['bmi'].mean(), inplace=True)

# Atau imputasi dengan median (jika data miring/skewed)
df['bmi'].fillna(df['bmi'].median(), inplace=True)

"""Kita cek kembali missing values"""

df.isnull().sum()

"""Mengecek total kategori pada fitur gender"""

print(df['gender'].value_counts())

gender_mode = df['gender'].mode()[0]

df['gender'] = df['gender'].replace('Other', gender_mode)

"""Mengecek dan menangani Outlier"""

# Menentukan kolom numerik yang akan dianalisis
fitur_numerik = ['age', 'bmi', 'avg_glucose_level']

# Menyimpan nilai-nilai outlier untuk setiap kolom
nilai_outlier = {}

# Visualisasi boxplot sebelum penanganan outlier
fig, axes = plt.subplots(1, len(fitur_numerik), figsize=(5 * len(fitur_numerik), 5))

# Jika hanya ada satu fitur, jadikan axes dalam bentuk list
if len(fitur_numerik) == 1:
    axes = [axes]

# Membuat boxplot awal untuk setiap fitur numerik
for ax, kolom in zip(axes, fitur_numerik):
    sns.boxplot(x=df[kolom], ax=ax)
    ax.set_title(f"Sebelum: {kolom}")

plt.tight_layout()
plt.show()

# Menangani outlier dengan metode IQR
for kolom in fitur_numerik:
    kuartil_1 = np.percentile(df[kolom].dropna(), 25)
    kuartil_3 = np.percentile(df[kolom].dropna(), 75)
    rentang_iqr = kuartil_3 - kuartil_1
    batas_bawah = kuartil_1 - 1.5 * rentang_iqr
    batas_atas = kuartil_3 + 1.5 * rentang_iqr

    outlier = df[kolom][(df[kolom] < batas_bawah) | (df[kolom] > batas_atas)]
    nilai_outlier[kolom] = outlier

    # Clipping nilai di luar batas menjadi batas atas/bawah
    df[kolom] = np.clip(df[kolom], batas_bawah, batas_atas)

# Menampilkan jumlah outlier yang terdeteksi sebelum clipping
print("\nTotal Outlier pada Setiap Fitur (Sebelum Clipping):")
for kolom, outlier in nilai_outlier.items():
    print(f"{kolom}: {len(outlier)} outlier")

# Visualisasi boxplot setelah outlier ditangani
fig, axes = plt.subplots(1, len(fitur_numerik), figsize=(5 * len(fitur_numerik), 5))

if len(fitur_numerik) == 1:
    axes = [axes]

for ax, kolom in zip(axes, fitur_numerik):
    sns.boxplot(x=df[kolom], ax=ax)
    ax.set_title(f"Sesudah: {kolom}")

plt.tight_layout()
plt.show()

"""### 3.3. Univariate Analysis

Mengelompokan kolom ke numerik dan kategorikal.
"""

# Fitur numerik (tipe data angka kontinu dan diskret)
fitur_numerik = ['age', 'bmi', 'avg_glucose_level']

# Fitur kategorik (tipe data object atau kategorikal)
fitur_kategorikal = ['gender', 'hypertension', 'heart_disease', 'ever_married', 'work_type', 'Residence_type', 'smoking_status', 'stroke']

"""Memvisualisasi untuk melihat distibusi nilai dari semua kolom numerik."""

# Membuat figure dengan ukuran menyesuaikan jumlah fitur numerik
plt.figure(figsize=(5 * len(fitur_numerik), 4))

# Loop untuk visualisasi distribusi tiap fitur numerik
for idx, kolom in enumerate(fitur_numerik, start=1):
    plt.subplot(1, len(fitur_numerik), idx)

    # Memilih warna berdasarkan jumlah fitur
    warna = sns.color_palette("husl", len(fitur_numerik))[idx - 1]

    # Menentukan jenis plot berdasarkan jumlah nilai unik
    if df[kolom].nunique() > 10:
        sns.histplot(df[kolom].dropna(), bins=30, kde=True, color=warna)
    else:
        sns.countplot(x=df[kolom], palette="husl")

    # Memberi label dan judul
    plt.title(f"Sebaran {kolom}")
    plt.xlabel(kolom)
    plt.ylabel("Jumlah")

# Mengatur layout agar tidak saling bertumpuk
plt.tight_layout()
plt.show()

"""Memvisualisasi untuk melihat distibusi persebaran nilai dari masing masing kategori dari semua kolom Kategori."""

# Menentukan ukuran figure untuk seluruh plot
plt.figure(figsize=(15, 13))

# Daftar palet warna yang digunakan untuk tiap plot
daftar_palettes = ["viridis", "magma", "coolwarm", "plasma", "cividis", "inferno"]

# Menampilkan jumlah dan persentase setiap kategori pada fitur kategorikal
for fitur in fitur_kategorikal:
    jumlah = df[fitur].value_counts()
    persentase = 100 * df[fitur].value_counts(normalize=True)

    distribusi_df = pd.DataFrame({
        'Jumlah Sampel': jumlah,
        'Persentase (%)': persentase.round(1)
    })

    print(f"\nRangkuman Kategori pada '{fitur}':")
    print(distribusi_df)
    print("-" * 50)

# Membuat visualisasi distribusi kategori menggunakan countplot
for idx, (fitur, palet) in enumerate(zip(fitur_kategorikal, daftar_palettes), start=1):
    plt.subplot(4, 3, idx)
    sns.countplot(
        y=df[fitur],
        order=df[fitur].value_counts().index,
        hue=df[fitur],
        palette=palet,
        legend=False
    )
    plt.title(f"Sebaran {fitur}")
    plt.xlabel("Jumlah")
    plt.ylabel(fitur)

# Mengatur layout agar plot tidak saling bertumpukan
plt.tight_layout()
plt.show()

"""### 3.4. Multivariate Analysis

Melihat rata rata stroke vs fitur lain dalam dataset
"""

# Daftar fitur bertipe kategorikal
fitur_kategorikal = ['gender', 'hypertension', 'heart_disease', 'ever_married', 'work_type', 'Residence_type', 'smoking_status']

# Menyusun subplot dalam grid 2 baris x 4 kolom untuk tampilan yang lebih rapi
fig, axes = plt.subplots(2, 4, figsize=(20, 10))
axes = axes.flatten()  # Ubah array 2D menjadi 1D agar mudah diakses per indeks

# Membuat barplot untuk masing-masing fitur kategorikal terhadap rata-rata stroke
for idx, fitur in enumerate(fitur_kategorikal):
    sns.barplot(
        x=fitur,
        y='stroke',
        data=df,
        ax=axes[idx],
        estimator=lambda val: sum(val) / len(val),
        errorbar=None
    )
    axes[idx].set_title(f"Rata-rata Kasus Stroke berdasarkan {fitur}")
    axes[idx].tick_params(axis='x', rotation=45)  # Memiringkan label sumbu-x agar tidak bertumpuk

# Menghapus subplot yang tidak terpakai jika jumlah fitur lebih sedikit dari jumlah subplot
for k in range(len(fitur_kategorikal), len(axes)):
    fig.delaxes(axes[k])

# Menyesuaikan layout agar visualisasi tidak saling menimpa
plt.tight_layout()
plt.show()

"""Memvisualisasikan hubungan antar variabel dalam dataset."""

sns.pairplot(df, diag_kind = 'kde')

"""Visualisasi correlation matrix untuk melihat korelasi atau hubungan fitur-fitur yang ada terhadap target atau label (stroke)."""

# Mengambil nama-nama kolom dengan tipe data numerik
fitur_numerik = df.select_dtypes(include=['number']).columns

# Membuat figure dengan ukuran tertentu
plt.figure(figsize=(10, 8))

# Menghitung korelasi antar fitur numerik dan membulatkan hingga dua desimal
matriks_korelasi = df[fitur_numerik].corr().round(2)

# Visualisasi korelasi dalam bentuk heatmap
sns.heatmap(
    data=matriks_korelasi,
    annot=True,
    cmap='coolwarm',
    linewidths=0.5
)
plt.title("Matriks Korelasi antar Fitur Numerik", fontsize=20)

"""## **4. Data Preparation**

### 4.1. Encoding Fitur Kategori

Mengencoding fitur kategori (gender dan smoking_status) ke fitur numerik menggunakan OneHotEncoder.
"""

# Menentukan kolom-kolom kategorikal yang akan dikonversi
fitur_kategorikal = ['gender', 'ever_married', 'work_type', 'Residence_type', 'smoking_status']

# Inisialisasi encoder dengan pengaturan untuk mengabaikan kategori yang tidak dikenal
ohe = OneHotEncoder(handle_unknown="ignore", sparse_output=False)

# Melakukan transformasi one-hot encoding
hasil_encoding = ohe.fit_transform(df[fitur_kategorikal])

# Membuat DataFrame baru dari hasil encoding
df_encoded = pd.DataFrame(
    hasil_encoding,
    columns=ohe.get_feature_names_out(fitur_kategorikal),
    index=df.index
)

# Menghapus kolom aslinya dan menggantinya dengan versi yang sudah diencoding
df.drop(columns=fitur_kategorikal, inplace=True)
df = pd.concat([df, df_encoded], axis=1)

"""Mengecek hasil dari OneHotEncoder yang membuat fitur baru dari hasil encoding."""

df.head()

"""### 4.2. Standarisasi Fitur

Melakukan standarisasi atau normalisasi fitur numerik yang rentangnya beragam seperti kolom 'age', 'bmi', dan 'avg_glucose_level' menggunakan StandardScaler untuk menyamakan rentang nilai.
"""

# Daftar fitur numerik yang akan dinormalisasi
fitur_numerik = ['age', 'bmi', 'avg_glucose_level']

# Inisialisasi objek StandardScaler
standarisasi = StandardScaler()

# Menerapkan standardisasi ke kolom-kolom numerik
df[fitur_numerik] = standarisasi.fit_transform(df[fitur_numerik])

"""Melihat hasil perubahan dari nilai pada fitur numerik yang ditentukan sebelumnya."""

df.head()

"""### 4.3. Train-Test-Split"""

# Memisahkan fitur dan target
fitur = df.drop(columns=["stroke"])
target = df["stroke"]

# Membagi dataset menjadi data pelatihan dan pengujian
X_train, X_test, y_train, y_test = train_test_split(
    fitur,
    target,
    test_size=0.3,
    random_state=123
)

# Menampilkan dimensi masing-masing subset data
print(f"Ukuran X_train: {X_train.shape}")
print(f"Ukuran y_train: {y_train.shape}")
print(f"Ukuran X_test: {X_test.shape}")
print(f"Ukuran y_test: {y_test.shape}")

"""## **5. Model Development**

### 5.1. Random Forest

Load model Random Forest dan melatihnya dengan data train.
"""

# Inisialisasi model Random Forest dengan 100 pohon dan nilai random state untuk reprodusibilitas
rf_model = RandomForestClassifier(n_estimators=100, random_state=123)

# Melatih model menggunakan data pelatihan
rf_model.fit(X_train, y_train)

"""### 5.2. XGBoost

Load model XGBoost dan melatihnya dengan data train.
"""

# Inisialisasi model XGBoost dengan pengaturan evaluasi logloss dan random state untuk hasil yang konsisten
xgb_model = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=123)

# Melatih model XGBoost pada data pelatihan
xgb_model.fit(X_train, y_train)

"""### 5.3 LightGBM

Load model LightGBM dan melatihnya dengan data train.
"""

# Membuat instance model LightGBM dengan parameter random state untuk hasil yang konsisten
lgbm_model = LGBMClassifier(random_state=123)

# Melatih model LightGBM menggunakan data pelatihan
lgbm_model.fit(X_train, y_train)

"""## **6. Evaluasi Model**

### 6.1. Random Forest

Evaluasi metrik accuracy_score dan classification_report (precision, recall dan f1-score) pada model Random Forest.
"""

# Melakukan prediksi menggunakan model Random Forest pada data uji
y_pred_test = rf_model.predict(X_test)

# Menghitung akurasi pada data uji
akurasi_test = accuracy_score(y_test, y_pred_test)

print(f"\nModel yang digunakan: Random Forest")
print(f"Akurasi pada data uji: {akurasi_test:.4f}")

print("\n--- Laporan Klasifikasi untuk Random Forest ---\n", classification_report(y_test, y_pred_test))

# Membuat confusion matrix
cm_test = confusion_matrix(y_test, y_pred_test)

print("Confusion Matrix untuk Random Forest:")
print(cm_test)

# Visualisasi confusion matrix dengan heatmap
fig, ax = plt.subplots(figsize=(5, 4))
sns.heatmap(cm_test, annot=True, fmt='d', cmap='Greens', ax=ax)
ax.set_title("Confusion Matrix Random Forest")
ax.set_xlabel("Label Prediksi")
ax.set_ylabel("Label Sebenarnya")

plt.tight_layout()
plt.show()

"""### 6.2. XGBoost

Evaluasi metrik accuracy_score dan classification_report (precision, recall dan f1-score) pada model XGBoost.
"""

# Prediksi label pada data uji menggunakan model XGBoost
y_pred_test = xgb_model.predict(X_test)

# Menghitung akurasi dari prediksi
akurasi_test = accuracy_score(y_test, y_pred_test)

print(f"\nModel yang digunakan: XGBoost")
print(f"Akurasi pada data uji: {akurasi_test:.4f}")

print("\n--- Laporan Klasifikasi untuk XGBoost ---\n", classification_report(y_test, y_pred_test))

# Membuat confusion matrix
cm_test = confusion_matrix(y_test, y_pred_test)

print("Confusion Matrix untuk XGBoost:")
print(cm_test)

# Visualisasi confusion matrix menggunakan heatmap dengan palet warna merah
fig, ax = plt.subplots(figsize=(5, 4))
sns.heatmap(cm_test, annot=True, fmt='d', cmap='Reds', ax=ax)
ax.set_title("Confusion Matrix XGBoost")
ax.set_xlabel("Label Prediksi")
ax.set_ylabel("Label Asli")

plt.tight_layout()
plt.show()

"""### 6.3. LightGBM

Evaluasi metrik accuracy_score dan classification_report (precision, recall dan f1-score) pada model LightGBM.
"""

# Melakukan prediksi pada data test menggunakan model LightGBM
y_pred_test = lgbm_model.predict(X_test)

# Menghitung akurasi prediksi
akurasi_test = accuracy_score(y_test, y_pred_test)

print(f"\nModel yang digunakan: LightGBM")
print(f"Akurasi pada data uji: {akurasi_test:.4f}")

print("\n--- Laporan Klasifikasi LightGBM ---\n", classification_report(y_test, y_pred_test))

# Membuat confusion matrix
cm_test = confusion_matrix(y_test, y_pred_test)

print("Confusion Matrix untuk LightGBM:")
print(cm_test)

# Menampilkan heatmap confusion matrix dengan palet warna biru
fig, ax = plt.subplots(figsize=(5, 4))
sns.heatmap(cm_test, annot=True, fmt='d', cmap='Blues', ax=ax)
ax.set_title("Confusion Matrix LightGBM")
ax.set_xlabel("Label Prediksi")
ax.set_ylabel("Label Asli")

plt.tight_layout()
plt.show()